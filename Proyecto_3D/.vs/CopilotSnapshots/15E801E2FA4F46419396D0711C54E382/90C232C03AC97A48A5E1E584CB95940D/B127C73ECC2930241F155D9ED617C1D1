using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;

namespace Proyecto_3D
{
    /// <summary>
    /// Motor de renderizado y transformaciones 3D con iluminación
    /// </summary>
    public class Motor3D
    {
        public enum ModoCamara
        {
            Orbital,
            Libre,
            Fija
        }

        public Punto3D PosicionCamara { get; set; }
        public Punto3D ObjetivoCamara { get; set; }
        public Punto3D UpCamara { get; set; }

        public double DistanciaCamara { get; set; }
        public double AnguloOrbitaH { get; set; }
        public double AnguloOrbitaV { get; set; }

        public double CampoVision { get; set; }
        public double AspectRatio { get; set; }
        public double PlanosCercano { get; set; }
        public double PlanosLejano { get; set; }

        public int AnchoVista { get; set; }
        public int AltoVista { get; set; }

        public Punto3D DireccionLuz { get; set; }

        // Nuevo: modo de cámara y propiedades para cámara libre
        public ModoCamara CamaraModo { get; set; } = ModoCamara.Orbital;

        public Punto3D FreeCamPos { get; set; }
        public double FreeCamYaw { get; set; }
        public double FreeCamPitch { get; set; }
        public double FreeCamSpeed { get; set; } = 0.2; // unidades por evento

        public Motor3D(int ancho, int alto)
        {
            AnchoVista = ancho;
            AltoVista = alto;

            DistanciaCamara = 5;
            AnguloOrbitaH = 45;
            AnguloOrbitaV = 30;
            ObjetivoCamara = new Punto3D(0, 0, 0);
            UpCamara = new Punto3D(0, 1, 0);

            ActualizarPosicionCamara();

            // Inicializar cámara libre con la posición orbital actual
            FreeCamPos = PosicionCamara.Clone();
            FreeCamYaw = AnguloOrbitaH;
            FreeCamPitch = AnguloOrbitaV;

            CampoVision = 60;
            AspectRatio = (double)ancho / alto;
            PlanosCercano = 0.1;
            PlanosLejano = 100;

            DireccionLuz = new Punto3D(1, -1, -1).VectorNormalizado();
        }

        public void ActualizarPosicionCamara()
        {
            if (CamaraModo == ModoCamara.Fija)
            {
                // En modo fija, no se recalcula la posición automáticamente
                return;
            }

            if (CamaraModo == ModoCamara.Libre)
            {
                // Convertir yaw/pitch a vector forward
                double radYaw = FreeCamYaw * Math.PI / 180.0;
                double radPitch = FreeCamPitch * Math.PI / 180.0;

                double fx = Math.Cos(radPitch) * Math.Sin(radYaw);
                double fy = Math.Cos(radPitch) * Math.Cos(radYaw);
                double fz = Math.Sin(radPitch);

                Punto3D forward = new Punto3D(fx, fy, fz).VectorNormalizado();

                PosicionCamara = FreeCamPos.Clone();
                ObjetivoCamara = PosicionCamara + forward; // un punto delante
                return;
            }

            // Modo orbital (comportamiento existente)
            double radianesH = AnguloOrbitaH * Math.PI / 180.0;
            double radianesV = AnguloOrbitaV * Math.PI / 180.0;

            double x = DistanciaCamara * Math.Cos(radianesV) * Math.Sin(radianesH);
            double y = DistanciaCamara * Math.Sin(radianesV);
            double z = DistanciaCamara * Math.Cos(radianesV) * Math.Cos(radianesH);

            PosicionCamara = new Punto3D(
                ObjetivoCamara.X + x,
                ObjetivoCamara.Y + y,
                ObjetivoCamara.Z + z
            );
        }

        public void RotarCamara(double deltaH, double deltaV)
        {
            if (CamaraModo == ModoCamara.Libre)
            {
                RotarCamaraLibre(deltaH, deltaV);
                return;
            }

            AnguloOrbitaH += deltaH;
            AnguloOrbitaV += deltaV;

            if (AnguloOrbitaV > 89) AnguloOrbitaV = 89;
            if (AnguloOrbitaV < -89) AnguloOrbitaV = -89;

            ActualizarPosicionCamara();
        }

        public void ZoomCamara(double delta)
        {
            if (CamaraModo == ModoCamara.Libre)
            {
                // Mover cámara libre hacia adelante/atrás
                MoverCamaraLibre(delta, 0, 0);
                return;
            }

            DistanciaCamara += delta;
            if (DistanciaCamara < 1) DistanciaCamara = 1;
            if (DistanciaCamara > 50) DistanciaCamara = 50;

            ActualizarPosicionCamara();
        }

        public void PanearCamara(double deltaX, double deltaY)
        {
            Punto3D adelante = (ObjetivoCamara - PosicionCamara).VectorNormalizado();
            Punto3D derecha = Punto3D.ProductoCruz(adelante, UpCamara).VectorNormalizado();
            Punto3D arriba = Punto3D.ProductoCruz(derecha, adelante).VectorNormalizado();

            double factor = DistanciaCamara * 0.001;
            ObjetivoCamara = ObjetivoCamara + (derecha * deltaX * factor) + (arriba * deltaY * factor);

            ActualizarPosicionCamara();
        }

        #region Transformaciones

        public Punto3D Trasladar(Punto3D punto, double tx, double ty, double tz)
        {
            return new Punto3D(punto.X + tx, punto.Y + ty, punto.Z + tz);
        }

        public Punto3D Escalar(Punto3D punto, Punto3D centro, double sx, double sy, double sz)
        {
            double x = centro.X + (punto.X - centro.X) * sx;
            double y = centro.Y + (punto.Y - centro.Y) * sy;
            double z = centro.Z + (punto.Z - centro.Z) * sz;
            return new Punto3D(x, y, z);
        }

        public Punto3D RotarX(Punto3D punto, Punto3D centro, double angulo)
        {
            double rad = angulo * Math.PI / 180.0;
            double cos = Math.Cos(rad);
            double sin = Math.Sin(rad);

            double y = punto.Y - centro.Y;
            double z = punto.Z - centro.Z;

            return new Punto3D(
                punto.X,
                centro.Y + y * cos - z * sin,
                centro.Z + y * sin + z * cos
            );
        }

        public Punto3D RotarY(Punto3D punto, Punto3D centro, double angulo)
        {
            double rad = angulo * Math.PI / 180.0;
            double cos = Math.Cos(rad);
            double sin = Math.Sin(rad);

            double x = punto.X - centro.X;
            double z = punto.Z - centro.Z;

            return new Punto3D(
                centro.X + x * cos + z * sin,
                punto.Y,
                centro.Z - x * sin + z * cos
            );
        }

        public Punto3D RotarZ(Punto3D punto, Punto3D centro, double angulo)
        {
            double rad = angulo * Math.PI / 180.0;
            double cos = Math.Cos(rad);
            double sin = Math.Sin(rad);

            double x = punto.X - centro.X;
            double y = punto.Y - centro.Y;

            return new Punto3D(
                centro.X + x * cos - y * sin,
                centro.Y + x * sin + y * cos,
                punto.Z
            );
        }

        public void AplicarTransformaciones(Figura3D figura)
        {
            if (figura.VerticesOriginales.Count == 0)
                return;

            // Usar el centro de la figura para transformaciones locales
            Punto3D centro = figura.ObtenerCentro();

            for (int i = 0; i < figura.Vertices.Count; i++)
            {
                Punto3D p = figura.VerticesOriginales[i].Clone();

                p = Escalar(p, centro, figura.Escala.X, figura.Escala.Y, figura.Escala.Z);
                p = RotarX(p, centro, figura.Rotacion.X);
                p = RotarY(p, centro, figura.Rotacion.Y);
                p = RotarZ(p, centro, figura.Rotacion.Z);
                p = Trasladar(p, figura.Posicion.X, figura.Posicion.Y, figura.Posicion.Z);

                figura.Vertices[i] = p;
            }

            // Calcular normales después de transformar
            figura.CalcularNormalesCaras();
        }

        #endregion

        #region Proyección y Renderizado

        public PointF ProyectarPunto(Punto3D punto)
        {
            // Vector forward (dirección mirada), right y up correctos
            Punto3D forward = (ObjetivoCamara - PosicionCamara).VectorNormalizado();
            Punto3D right = Punto3D.ProductoCruz(forward, UpCamara).VectorNormalizado();
            Punto3D up = Punto3D.ProductoCruz(right, forward).VectorNormalizado();

            Punto3D puntoRelativo = punto - PosicionCamara;

            double xe = Punto3D.ProductoPunto(puntoRelativo, right);
            double ye = Punto3D.ProductoPunto(puntoRelativo, up);
            double ze = Punto3D.ProductoPunto(puntoRelativo, forward);

            // Evitar planos demasiado cercanos o puntos detrás de la cámara
            if (ze <= PlanosCercano)
            {
                ze = PlanosCercano + 0.01;
            }

            double fov = CampoVision * Math.PI / 180.0;
            double d = 1.0 / Math.Tan(fov / 2.0);

            // Aplicar aspect ratio en X (correcto) y mapear a NDC
            double xp = (xe * d) / (ze * AspectRatio);
            double yp = (ye * d) / ze;

            float screenX = (float)((xp + 1) * AnchoVista / 2);
            float screenY = (float)((1 - yp) * AltoVista / 2);

            return new PointF(screenX, screenY);
        }

        private Color CalcularColorConIluminacion(Figura3D figura, Punto3D normal)
        {
            // Componente ambiente
            double ambiente = figura.LuzAmbiente;

            // Componente difusa (Lambert)
            double difusa = Math.Max(0, -Punto3D.ProductoPunto(normal, DireccionLuz));
            difusa *= figura.IntensidadLuz;

            // Combinar ambiente + difusa
            double factorLuz = Math.Min(1.0, ambiente + difusa);

            // Obtener color base según textura
            Color colorBase = figura.ObtenerColorTextura();

            // Aplicar propiedades especiales por textura
            switch (figura.TipoTextura)
            {
                case TipoTextura.Cristal:
                    // Cristal: más transparente y con brillo
                    factorLuz = Math.Min(1.0, factorLuz * 1.3);
                    break;

                case TipoTextura.Diamante:
                    // Diamante: muy brillante
                    factorLuz = Math.Min(1.0, factorLuz * 1.5 + 0.2);
                    break;

                case TipoTextura.Oro:
                    // Oro: reflejo metálico
                    factorLuz = Math.Min(1.0, factorLuz * 1.2 + 0.1);
                    break;

                case TipoTextura.Piedra:
                    // Piedra: más opaco
                    factorLuz = Math.Max(0.3, factorLuz * 0.9);
                    break;

                case TipoTextura.Esponja:
                    // Esponja: difuso y suave
                    factorLuz = Math.Max(0.4, factorLuz);
                    break;
            }

            // Aplicar iluminación al color
            int r = (int)(colorBase.R * factorLuz);
            int g = (int)(colorBase.G * factorLuz);
            int b = (int)(colorBase.B * factorLuz);

            r = Math.Max(0, Math.Min(255, r));
            g = Math.Max(0, Math.Min(255, g));
            b = Math.Max(0, Math.Min(255, b));

            return Color.FromArgb(colorBase.A, r, g, b);
        }

        private Brush CrearBrushTextura(Figura3D figura, Punto3D normal, PointF[] puntos)
        {
            Color colorIluminado = CalcularColorConIluminacion(figura, normal);

            switch (figura.TipoTextura)
            {
                case TipoTextura.Cristal:
                    // Degradado con efecto vidrio
                    if (puntos.Length >= 2)
                    {
                        Color c1 = Color.FromArgb(colorIluminado.A,
                            Math.Min(255, colorIluminado.R + 40),
                            Math.Min(255, colorIluminado.G + 40),
                            Math.Min(255, colorIluminado.B + 40));

                        try
                        {
                            return new LinearGradientBrush(
                                puntos[0],
                                puntos[puntos.Length / 2],
                                c1, colorIluminado);
                        }
                        catch
                        {
                            return new SolidBrush(colorIluminado);
                        }
                    }
                    return new SolidBrush(colorIluminado);

                case TipoTextura.Diamante:
                    // Efecto brillante con degradado
                    if (puntos.Length >= 2)
                    {
                        Color c1 = Color.FromArgb(colorIluminado.A, 255, 255, 255);
                        try
                        {
                            return new LinearGradientBrush(
                                puntos[0],
                                puntos[puntos.Length - 1],
                                c1, colorIluminado);
                        }
                        catch
                        {
                            return new SolidBrush(colorIluminado);
                        }
                    }
                    return new SolidBrush(colorIluminado);

                case TipoTextura.Oro:
                    // Degradado dorado
                    if (puntos.Length >= 2)
                    {
                        Color c1 = Color.FromArgb(colorIluminado.A,
                            Math.Min(255, colorIluminado.R + 30),
                            Math.Min(255, colorIluminado.G + 20),
                            colorIluminado.B);

                        try
                        {
                            return new LinearGradientBrush(
                                puntos[0],
                                puntos[puntos.Length / 2],
                                colorIluminado, c1);
                        }
                        catch
                        {
                            return new SolidBrush(colorIluminado);
                        }
                    }
                    return new SolidBrush(colorIluminado);

                case TipoTextura.Piedra:
                    // Color sólido mate
                    return new SolidBrush(colorIluminado);

                case TipoTextura.Esponja:
                    // Color sólido más suave
                    return new SolidBrush(colorIluminado);

                default:
                    return new SolidBrush(colorIluminado);
            }
        }

        public void DibujarFigura(Graphics g, Figura3D figura)
        {
            if (!figura.Visible || figura.Vertices.Count == 0)
                return;

            List<PointF> puntosProyectados = new List<PointF>();
            foreach (var vertice in figura.Vertices)
            {
                puntosProyectados.Add(ProyectarPunto(vertice));
            }

            // Dibujar caras con iluminación y ordenado por profundidad (painter)
            if (figura.MostrarRelleno && figura.Caras.Count > 0)
            {
                // Calcular profundidad media de cada cara
                var listaCaras = new List<Tuple<int, double>>(); // (index, depth)
                Punto3D dirCamara = (PosicionCamara - figura.ObtenerCentro()).VectorNormalizado();

                for (int i = 0; i < figura.Caras.Count; i++)
                {
                    var cara = figura.Caras[i];
                    double suma = 0;
                    int cnt = 0;
                    foreach (int idx in cara)
                    {
                        if (idx < figura.Vertices.Count)
                        {
                            Punto3D v = figura.Vertices[idx];
                            Punto3D rel = v - PosicionCamara;
                            suma += Punto3D.ProductoPunto(rel, dirCamara);
                            cnt++;
                        }
                    }
                    double media = (cnt > 0) ? (suma / cnt) : 0;
                    listaCaras.Add(Tuple.Create(i, media));
                }

                // Ordenar de más lejano a más cercano
                listaCaras.Sort((a, b) => b.Item2.CompareTo(a.Item2));

                // Dibujar en ese orden
                for (int idxLista = 0; idxLista < listaCaras.Count; idxLista++)
                {
                    int i = listaCaras[idxLista].Item1;
                    var cara = figura.Caras[i];
                    if (cara.Count < 3) continue;

                    PointF[] puntos = new PointF[cara.Count];
                    bool todosValidos = true;

                    for (int j = 0; j < cara.Count; j++)
                    {
                        if (cara[j] >= puntosProyectados.Count)
                        {
                            todosValidos = false;
                            break;
                        }
                        puntos[j] = puntosProyectados[cara[j]];
                    }

                    if (!todosValidos) continue;

                    Punto3D normal = i < figura.NormalesCaras.Count
                        ? figura.NormalesCaras[i]
                        : new Punto3D(0, 1, 0);

                    // Backface culling: solo dibujar caras cuyo normal apunte hacia la cámara
                    // Calcular vector desde la cara al centro de la cámara
                    Punto3D centroCara = new Punto3D(0,0,0);
                    foreach (int vi in cara)
                    {
                        if (vi < figura.Vertices.Count) centroCara += figura.Vertices[vi];
                    }
                    centroCara = centroCara * (1.0 / cara.Count);
                    Punto3D toCamera = (PosicionCamara - centroCara).VectorNormalizado();

                    double dot = Punto3D.ProductoPunto(normal, toCamera);
                    if (dot <= 0) // cara orientada hacia atrás
                        continue;

                    try
                    {
                        using (Brush brush = CrearBrushTextura(figura, normal, puntos))
                        {
                            // Si el brush es sólido con alpha alta, usar FillPolygon directamente
                            g.FillPolygon(brush, puntos);
                        }
                    }
                    catch { }
                }

                // Dibujar contorno de las caras con el color de línea de la figura.
                // Si está seleccionada, usar grosor 2; en caso contrario, grosor 1.
                using (Pen penLinea = new Pen(figura.ColorLinea, figura.Seleccionada ? 2 : 1))
                {
                    penLinea.Alignment = PenAlignment.Center;
                    foreach (var cara in figura.Caras)
                    {
                        if (cara.Count < 2) continue;
                        PointF[] pts = new PointF[cara.Count];
                        bool ok = true;
                        for (int k = 0; k < cara.Count; k++)
                        {
                            if (cara[k] >= puntosProyectados.Count) { ok = false; break; }
                            pts[k] = puntosProyectados[cara[k]];
                        }
                        if (!ok) continue;
                        try { g.DrawPolygon(penLinea, pts); } catch { }
                    }
                }
            }
            else
            {
                // Modo wireframe: dibujar aristas con color de línea
                using (Pen penBase = new Pen(figura.ColorLinea, 1))
                {
                    foreach (var arista in figura.Aristas)
                    {
                        if (arista.Inicio < puntosProyectados.Count &&
                            arista.Fin < puntosProyectados.Count)
                        {
                            try
                            {
                                g.DrawLine(penBase,
                                    puntosProyectados[arista.Inicio],
                                    puntosProyectados[arista.Fin]);
                            }
                            catch { }
                        }
                    }
                }

                // Si está seleccionada, dibujar overlay para destacar
                if (figura.Seleccionada)
                {
                    using (Pen penSel = new Pen(figura.ColorLinea, 2))
                    {
                        penSel.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;
                        foreach (var arista in figura.Aristas)
                        {
                            if (arista.Inicio < puntosProyectados.Count &&
                                arista.Fin < puntosProyectados.Count)
                            {
                                try
                                {
                                    g.DrawLine(penSel,
                                        puntosProyectados[arista.Inicio],
                                        puntosProyectados[arista.Fin]);
                                }
                                catch { }
                            }
                        }
                    }
                }
            }
        }

        public void DibujarEjes(Graphics g, double longitud = 2)
        {
            Punto3D origen = new Punto3D(0, 0, 0);
            Punto3D ejeX = new Punto3D(longitud, 0, 0);
            Punto3D ejeY = new Punto3D(0, 0, longitud);
            Punto3D ejeZ = new Punto3D(0, longitud, 0);

            PointF pOrigen = ProyectarPunto(origen);
            PointF pX = ProyectarPunto(ejeX);
            PointF pY = ProyectarPunto(ejeY);
            PointF pZ = ProyectarPunto(ejeZ);

            using (Pen penX = new Pen(Color.Red, 2))
            using (Pen penY = new Pen(Color.Lime, 2))
            using (Pen penZ = new Pen(Color.Blue, 2))
            using (Brush labelBrush = new SolidBrush(Color.White))
            using (Font f = new Font("Segoe UI", 9))
            {
                try { g.DrawLine(penX, pOrigen, pX); } catch { }
                try { g.DrawLine(penY, pOrigen, pY); } catch { }
                try { g.DrawLine(penZ, pOrigen, pZ); } catch { }

                // Dibujar etiquetas para evitar confusiones
                float off = 4f;
                try { g.DrawString("X", f, labelBrush, pX.X + off, pX.Y + off); } catch { }
                try { g.DrawString("Y", f, labelBrush, pY.X + off, pY.Y + off); } catch { }
                try { g.DrawString("Z", f, labelBrush, pZ.X + off, pZ.Y + off); } catch { }
            }
        }

        public void DibujarGrid(Graphics g, int tamaño = 10, double espaciado = 1)
        {
            using (Pen penGrid = new Pen(Color.FromArgb(50, 255, 255, 255), 1))
            {
                for (int i = -tamaño; i <= tamaño; i++)
                {
                    double pos = i * espaciado;

                    PointF p1 = ProyectarPunto(new Punto3D(-tamaño * espaciado, 0, pos));
                    PointF p2 = ProyectarPunto(new Punto3D(tamaño * espaciado, 0, pos));
                    try { g.DrawLine(penGrid, p1, p2); } catch { }

                    p1 = ProyectarPunto(new Punto3D(pos, 0, -tamaño * espaciado));
                    p2 = ProyectarPunto(new Punto3D(pos, 0, tamaño * espaciado));
                    try { g.DrawLine(penGrid, p1, p2); } catch { }
                }
            }
        }

        #endregion

        // Métodos para cámara libre
        public void MoverCamaraLibre(double forward, double right, double up)
        {
            Punto3D forwardVec = (ObjetivoCamara - PosicionCamara).VectorNormalizado();
            Punto3D rightVec = Punto3D.ProductoCruz(forwardVec, UpCamara).VectorNormalizado();
            Punto3D upVec = Punto3D.ProductoCruz(rightVec, forwardVec).VectorNormalizado();

            FreeCamPos = FreeCamPos + (forwardVec * forward) + (rightVec * right) + (upVec * up);
            ActualizarPosicionCamara();
        }

        public void RotarCamaraLibre(double yawDelta, double pitchDelta)
        {
            FreeCamYaw += yawDelta;
            FreeCamPitch += pitchDelta;
            if (FreeCamPitch > 89) FreeCamPitch = 89;
            if (FreeCamPitch < -89) FreeCamPitch = -89;
            ActualizarPosicionCamara();
        }
    }
}